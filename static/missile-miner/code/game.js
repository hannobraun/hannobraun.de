// Generated by CoffeeScript 1.4.0
(function() {

  window.module = function(moduleName, dependencyNames, moduleFactory) {
    if (window.modules == null) {
      window.modules = {};
    }
    if (window.modules[moduleName] == null) {
      return window.modules[moduleName] = {
        name: moduleName,
        dependencyNames: dependencyNames,
        factory: moduleFactory
      };
    } else {
      throw "Module " + moduleName + " is already defined.";
    }
  };

  window.load = function(moduleName, loadedModules) {
    var dependencies, dependencyName, module, _i, _len, _ref;
    if (window.modules == null) {
      throw "No modules have been defined.";
    }
    if (window.modules[moduleName] == null) {
      throw "A module called " + moduleName + " does not exist.";
    }
    if (loadedModules == null) {
      loadedModules = {};
    }
    if (loadedModules[moduleName] == null) {
      module = window.modules[moduleName];
      dependencies = {};
      _ref = module.dependencyNames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dependencyName = _ref[_i];
        if (modules[dependencyName] == null) {
          throw ("A module called \"" + dependencyName + "\" (defined as a ") + ("dependency in \"" + moduleName + "\") does not exist.");
        }
        dependencies[dependencyName] = load(dependencyName, loadedModules);
      }
      loadedModules[moduleName] = module.factory(dependencies);
    }
    return loadedModules[moduleName];
  };

  module("Miners", ["Bodies", "MinerControls"], function(m) {
    var module, nextEntityId;
    nextEntityId = 0;
    return module = {
      createMiner: function(args) {
        var body, entity, id;
        body = m.Bodies.createBody();
        body.radius = 4;
        id = "miner" + nextEntityId;
        nextEntityId += 1;
        return entity = {
          id: id,
          components: {
            "bodies": body,
            "minerControls": m.MinerControls.createMinerControl(),
            "imageIds": "miner.png"
          }
        };
      }
    };
  });

  module("Missiles", ["Vec2", "Bodies", "MissileControls"], function(m) {
    var module, nextEntityId;
    nextEntityId = 0;
    return module = {
      createMissile: function(args) {
        var body, entity, id, missileControl;
        body = m.Bodies.createBody();
        body.position = m.Vec2.copy(args.position);
        body.radius = 1;
        missileControl = m.MissileControls.createMissileControl(args.targetId);
        id = "missile" + nextEntityId;
        nextEntityId += 1;
        return entity = {
          id: id,
          components: {
            "bodies": body,
            "missileControls": missileControl,
            "imageIds": "missile.png"
          }
        };
      }
    };
  });

  module("Aliens", ["AlienControls", "Bodies"], function(m) {
    var module, nextEntityId;
    nextEntityId = 0;
    return module = {
      createAlien: function(args) {
        var alienControl, body, entity, id, x, y;
        x = args.fieldSize[0] / 2 + Math.random() * 100 - 50;
        y = Math.random() * args.fieldSize[1] - args.fieldSize[1] / 2;
        body = m.Bodies.createBody();
        body.position = [x, y];
        body.radius = 5;
        alienControl = m.AlienControls.createAlienControl(body.position);
        id = "alien" + nextEntityId;
        nextEntityId += 1;
        return entity = {
          id: id,
          components: {
            "bodies": body,
            "alienControls": alienControl,
            "imageIds": "alien.png"
          }
        };
      }
    };
  });

  module("Asteroids", ["AsteroidControls", "Bodies"], function(m) {
    var module, nextEntityId;
    nextEntityId = 0;
    return module = {
      createAsteroid: function(args) {
        var asteroidControl, body, entity, id;
        asteroidControl = m.AsteroidControls.createAsteroidControl();
        body = m.Bodies.createBody();
        body.position = [Math.random() * args.fieldSize[0], args.fieldSize[1] / 2];
        body.velocity = [Math.random() * 100 - 50, Math.random() * 100 - 50];
        body.radius = asteroidControl.initialRadius;
        id = "asteroid" + nextEntityId;
        nextEntityId += 1;
        return entity = {
          id: id,
          components: {
            "bodies": body,
            "asteroidControls": asteroidControl,
            "imageIds": "asteroid.png"
          }
        };
      }
    };
  });

  module("AsteroidControls", [], function(m) {
    var module;
    return module = {
      createAsteroidControl: function() {
        var asteroidControl;
        return asteroidControl = {
          initialRadius: 20,
          initialOre: 100,
          currentOre: 100
        };
      }
    };
  });

  module("MissileControls", [], function(m) {
    var module;
    return module = {
      createMissileControl: function(targetId) {
        var missileControl;
        return missileControl = {
          targetId: targetId,
          targetAcquired: false
        };
      }
    };
  });

  module("MinerControls", ["Input"], function(m) {
    var module;
    return module = {
      createMinerControl: function() {
        var minerControl;
        return minerControl = {
          health: 1,
          nearestAsteroidId: null,
          laserEfficiency: 0
        };
      },
      processInput: function(currentInput, frameTimeInS, minerControls, bodies) {
        var body, entityId, minerControl, rotationDirection, rotationInRadPerS, _results;
        _results = [];
        for (entityId in minerControls) {
          minerControl = minerControls[entityId];
          body = bodies[entityId];
          body.accelerationMagnitude = m.Input.isKeyDown(currentInput, "up arrow") ? 200 : 0;
          rotationDirection = 0;
          if (m.Input.isKeyDown(currentInput, "right arrow")) {
            rotationDirection = 1;
          }
          if (m.Input.isKeyDown(currentInput, "left arrow")) {
            rotationDirection = -1;
          }
          rotationInRadPerS = 4;
          _results.push(body.orientation += rotationInRadPerS * frameTimeInS * rotationDirection);
        }
        return _results;
      }
    };
  });

  module("Bodies", ["Vec2", "Transform2d"], function(m) {
    var module;
    return module = {
      createBody: function() {
        var body;
        return body = {
          position: [0, 0],
          velocity: [0, 0],
          orientation: 0,
          accelerationMagnitude: 0,
          radius: 1
        };
      },
      updateBodies: function(frameTimeInS, bodies) {
        var acceleration, body, entityId, frameMovement, orientationTransform, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          orientationTransform = m.Transform2d.rotationMatrix(body.orientation);
          acceleration = [body.accelerationMagnitude, 0];
          m.Vec2.applyTransform(acceleration, orientationTransform);
          m.Vec2.scale(acceleration, frameTimeInS);
          m.Vec2.add(body.velocity, acceleration);
          frameMovement = m.Vec2.copy(body.velocity);
          m.Vec2.scale(frameMovement, frameTimeInS);
          _results.push(m.Vec2.add(body.position, frameMovement));
        }
        return _results;
      }
    };
  });

  module("AlienControls", [], function(m) {
    var module;
    return module = {
      createAlienControl: function(initialPosition) {
        var alienControl;
        return alienControl = {
          waypoint: initialPosition,
          tubeDelay: 10,
          tubeACooldown: 10,
          tubeBCooldown: 9.75
        };
      }
    };
  });

  module("Logic", ["Input", "Entities", "Vec2", "Aliens", "Asteroids", "Miners", "Missiles", "Bodies", "MinerControls", "DetectCollisions", "DetectLoss", "ActivateMiningLaser", "AddScore", "RemoveOre", "DestroyAsteroids", "SpawnAlien", "ControlAliens", "ControlMissiles"], function(m) {
    var createEntity, destroyEntity, entityFactories, module;
    entityFactories = {
      "alien": m.Aliens.createAlien,
      "asteroid": m.Asteroids.createAsteroid,
      "miner": m.Miners.createMiner,
      "missile": m.Missiles.createMissile
    };
    createEntity = null;
    destroyEntity = null;
    return module = {
      createGameState: function(fieldSize) {
        var gameState;
        return gameState = {
          components: {},
          fieldSize: fieldSize,
          score: 0,
          nextAlienCountdownInS: 0
        };
      },
      initGameState: function(gameState) {
        var i, _i, _results;
        createEntity = function(type, args) {
          return m.Entities.createEntity(entityFactories, gameState.components, type, args);
        };
        destroyEntity = function(entityId) {
          return m.Entities.destroyEntity(gameState.components, entityId);
        };
        createEntity("miner", {});
        _results = [];
        for (i = _i = 1; _i <= 10; i = ++_i) {
          _results.push(createEntity("asteroid", {
            fieldSize: gameState.fieldSize
          }));
        }
        return _results;
      },
      updateGameState: function(gameState, currentInput, gameTimeInS, frameTimeInS) {
        var alienControls, asteroidControls, bodies, body, components, coordinate, entityId, fieldSize, i, limit, minerControls, missileControls, _i;
        components = gameState.components;
        fieldSize = gameState.fieldSize;
        alienControls = components["alienControls"];
        asteroidControls = components["asteroidControls"];
        bodies = components["bodies"];
        minerControls = components["minerControls"];
        missileControls = components["missileControls"];
        m.DestroyAsteroids(asteroidControls, destroyEntity);
        m.MinerControls.processInput(currentInput, frameTimeInS, gameState.components.minerControls, gameState.components.bodies);
        m.Bodies.updateBodies(frameTimeInS, gameState.components.bodies);
        for (entityId in bodies) {
          body = bodies[entityId];
          for (i = _i = 0; _i <= 1; i = ++_i) {
            limit = fieldSize[i] / 2;
            coordinate = body.position[i];
            if (coordinate > limit) {
              body.position[i] = -limit + (coordinate - limit);
            }
            if (coordinate < -limit) {
              body.position[i] = limit - (coordinate - limit);
            }
          }
        }
        m.DetectCollisions(minerControls, asteroidControls, bodies);
        m.DetectLoss(minerControls, destroyEntity);
        m.ActivateMiningLaser(minerControls, bodies);
        m.AddScore(frameTimeInS, minerControls, gameState);
        m.RemoveOre(frameTimeInS, minerControls, asteroidControls, bodies);
        m.SpawnAlien(gameState, frameTimeInS, createEntity, gameState.fieldSize);
        m.ControlAliens(frameTimeInS, alienControls, bodies, fieldSize, createEntity);
        return m.ControlMissiles(frameTimeInS, missileControls, bodies, destroyEntity);
      }
    };
  });

  module("ControlAliens", ["Vec2"], function(m) {
    return function(frameTimeInS, alienControls, bodies, fieldSize, createEntity) {
      var alienControl, alienSpeed, alienToWaypoint, angularMomentumPerS, body, distance, entityId, i, numberOfShots, threshold, velocity, x, y, _results;
      _results = [];
      for (entityId in alienControls) {
        alienControl = alienControls[entityId];
        body = bodies[entityId];
        angularMomentumPerS = 0.5;
        body.orientation += angularMomentumPerS * frameTimeInS;
        alienToWaypoint = m.Vec2.copy(alienControl.waypoint);
        m.Vec2.subtract(alienToWaypoint, body.position);
        distance = m.Vec2.length(alienToWaypoint);
        threshold = 10;
        if (distance < threshold) {
          x = Math.random() * fieldSize[0] - fieldSize[0] / 2;
          y = Math.random() * fieldSize[1] - fieldSize[1] / 2;
          alienControl.waypoint = [x, y];
          alienSpeed = 15;
          velocity = m.Vec2.copy(alienControl.waypoint);
          m.Vec2.subtract(velocity, body.position);
          m.Vec2.normalize(velocity);
          m.Vec2.scale(velocity, alienSpeed);
          body.velocity = velocity;
        }
        alienControl.tubeACooldown -= frameTimeInS;
        alienControl.tubeBCooldown -= frameTimeInS;
        numberOfShots = 0;
        if (alienControl.tubeACooldown <= 0) {
          alienControl.tubeACooldown = alienControl.tubeDelay;
          numberOfShots += 1;
        }
        if (alienControl.tubeBCooldown <= 0) {
          alienControl.tubeBCooldown = alienControl.tubeDelay;
          numberOfShots += 1;
        }
        i = 0;
        _results.push((function() {
          var _results1;
          _results1 = [];
          while (i < numberOfShots) {
            createEntity("missile", {
              position: body.position,
              targetId: "miner0"
            });
            _results1.push(i += 1);
          }
          return _results1;
        })());
      }
      return _results;
    };
  });

  module("RemoveOre", [], function(m) {
    var module;
    return module = function(frameTimeInS, minerControls, asteroidControls, bodies) {
      var asteroidBody, asteroidControl, asteroidId, baseHarvest, entityId, laserEfficiency, minerControl, removedOrePerS, _results;
      _results = [];
      for (entityId in minerControls) {
        minerControl = minerControls[entityId];
        laserEfficiency = minerControl.laserEfficiency;
        if (laserEfficiency > 0) {
          asteroidId = minerControl.nearestAsteroidId;
          asteroidBody = bodies[asteroidId];
          asteroidControl = asteroidControls[asteroidId];
          baseHarvest = 10;
          removedOrePerS = baseHarvest * laserEfficiency * laserEfficiency;
          asteroidControl.currentOre -= removedOrePerS * frameTimeInS;
          _results.push(asteroidBody.radius = asteroidControl.initialRadius * (asteroidControl.currentOre / asteroidControl.initialOre));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  });

  module("DetectLoss", [], function() {
    var module;
    return module = function(minerControls, destroyEntity) {
      var entityId, minerControl, _results;
      _results = [];
      for (entityId in minerControls) {
        minerControl = minerControls[entityId];
        if (minerControl.health <= 0) {
          _results.push(destroyEntity(entityId));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  });

  module("DestroyAsteroids", [], function(m) {
    var module;
    return module = function(asteroidControls, destroyEntity) {
      var asteroidControl, entityId, _results;
      _results = [];
      for (entityId in asteroidControls) {
        asteroidControl = asteroidControls[entityId];
        if (asteroidControl.currentOre <= 0) {
          _results.push(destroyEntity(entityId));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  });

  module("AddScore", [], function(m) {
    var module;
    return module = function(frameTimeInS, minerControls, gameState) {
      var entityId, laserEfficiency, minerControl, scoreBaseValue, scorePerS, _results;
      _results = [];
      for (entityId in minerControls) {
        minerControl = minerControls[entityId];
        laserEfficiency = minerControl.laserEfficiency;
        scoreBaseValue = 100;
        scorePerS = scoreBaseValue * laserEfficiency * laserEfficiency;
        _results.push(gameState.score += frameTimeInS * scorePerS);
      }
      return _results;
    };
  });

  module("DetectCollisions", ["Vec2"], function(m) {
    var module;
    return module = function(minerControls, asteroids, bodies) {
      var asteroid, asteroidBody, asteroidId, distance, minerBody, minerControl, minerId, minerToAsteroid, nearestDistance, radii, _results;
      _results = [];
      for (minerId in minerControls) {
        minerControl = minerControls[minerId];
        minerBody = bodies[minerId];
        nearestDistance = Number.MAX_VALUE;
        minerControl.nearestAsteroidId = null;
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (asteroidId in asteroids) {
            asteroid = asteroids[asteroidId];
            asteroidBody = bodies[asteroidId];
            minerToAsteroid = m.Vec2.copy(asteroidBody.position);
            m.Vec2.subtract(minerToAsteroid, minerBody.position);
            distance = m.Vec2.length(minerToAsteroid);
            radii = minerBody.radius + asteroidBody.radius;
            if (distance < radii) {
              minerControl.health -= 1;
            }
            if (distance < nearestDistance) {
              nearestDistance = distance;
              _results1.push(minerControl.nearestAsteroidId = asteroidId);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
  });

  module("ActivateMiningLaser", ["Vec2"], function(m) {
    var module;
    return module = function(minerControls, bodies) {
      var asteroidBody, distance, entityId, maxDistance, minerBody, minerControl, minerToAsteroid, _results;
      _results = [];
      for (entityId in minerControls) {
        minerControl = minerControls[entityId];
        if (minerControl.nearestAsteroidId !== null) {
          minerBody = bodies[entityId];
          asteroidBody = bodies[minerControl.nearestAsteroidId];
          minerToAsteroid = m.Vec2.copy(asteroidBody.position);
          m.Vec2.subtract(minerToAsteroid, minerBody.position);
          maxDistance = 100;
          distance = m.Vec2.length(minerToAsteroid);
          _results.push(minerControl.laserEfficiency = distance <= maxDistance ? 1 - distance * (1 / maxDistance) : 0);
        } else {
          _results.push(minerControl.laserEfficiency = 0);
        }
      }
      return _results;
    };
  });

  module("SpawnAlien", [], function(m) {
    return function(gameState, frameTimeInS, createEntity, fieldSize) {
      gameState.nextAlienCountdownInS -= frameTimeInS;
      if (gameState.nextAlienCountdownInS <= 0) {
        gameState.nextAlienCountdownInS = 30;
        return createEntity("alien", {
          fieldSize: gameState.fieldSize
        });
      }
    };
  });

  module("Graphics", ["Rendering", "Vec2"], function(m) {
    var module;
    return module = {
      createRenderState: function(displaySize) {
        var renderState;
        return renderState = {
          renderables: [],
          displaySize: displaySize
        };
      },
      updateRenderState: function(renderState, gameState) {
        var asteroidBody, asteroidControl, asteroidControls, bodies, body, components, entityId, imageId, imageIds, laser, maxWidth, minerBody, minerControl, minerControls, renderable, renderables, scale, score, width;
        components = gameState.components;
        asteroidControls = components.asteroidControls;
        bodies = components.bodies;
        imageIds = components.imageIds;
        minerControls = components.minerControls;
        renderables = renderState.renderables;
        renderables.length = 0;
        for (entityId in minerControls) {
          minerControl = minerControls[entityId];
          if (minerControl.laserEfficiency > 0) {
            minerBody = bodies[entityId];
            asteroidBody = bodies[minerControl.nearestAsteroidId];
            maxWidth = 5;
            width = maxWidth * minerControl.laserEfficiency;
            laser = m.Rendering.createRenderable("line", {
              start: minerBody.position,
              end: asteroidBody.position,
              width: width,
              color: "rgb(255,255,0)"
            });
            renderables.push(laser);
          }
        }
        for (entityId in bodies) {
          body = bodies[entityId];
          imageId = imageIds[entityId];
          asteroidControl = asteroidControls[entityId];
          scale = asteroidControl != null ? asteroidControl.currentOre / asteroidControl.initialOre : 1;
          renderable = m.Rendering.createRenderable("image", {
            position: body.position,
            orientation: body.orientation,
            scale: [scale, scale]
          }, imageId);
          renderables.push(renderable);
        }
        score = m.Rendering.createRenderable("text", {
          text: Math.floor(gameState.score),
          position: [0, -(renderState.displaySize[1] / 2 - 30)],
          color: "rgb(255,255,0)",
          font: "20pt Arial"
        });
        return renderables.push(score);
      }
    };
  });

  module("Main", ["Images", "Rendering", "Input", "MainLoop", "Step", "Logic", "Graphics"], function(m) {
    var imagePaths;
    imagePaths = ["images/alien.png", "images/asteroid.png", "images/miner.png", "images/missile.png"];
    return m.Images.loadImages(imagePaths, function(rawImages) {
      var currentInput, display, gameState, images, renderData, renderState, stepData;
      images = m.Images.process(rawImages);
      renderData = m.Rendering.createRenderData(m.Rendering.drawFunctions, {
        "image": images
      });
      m.Input.preventDefaultFor(["up arrow", "down arrow", "left arrow", "right arrow", "space"]);
      stepData = m.Step.createStepData(1 / 60);
      display = m.Rendering.createDisplay();
      currentInput = m.Input.createCurrentInput(display);
      gameState = m.Logic.createGameState(display.size);
      renderState = m.Graphics.createRenderState(display.size);
      m.Logic.initGameState(gameState);
      return m.MainLoop.execute(function(gameTimeInS, frameTimeInS) {
        m.Step.step(stepData, frameTimeInS, function(totalStepTimeInS, stepTimeInS) {
          return m.Logic.updateGameState(gameState, currentInput, totalStepTimeInS, stepTimeInS);
        });
        m.Graphics.updateRenderState(renderState, gameState);
        return m.Rendering.render(m.Rendering.drawFunctions, display, renderData, renderState.renderables);
      });
    });
  });

  module("Step", [], function(m) {
    var module;
    return module = {
      createStepData: function(stepTime) {
        return {
          stepTime: stepTime,
          accumulator: 0,
          totalTime: 0
        };
      },
      step: function(stepData, frameTime, f) {
        var _results;
        stepData.accumulator += frameTime;
        _results = [];
        while (stepData.accumulator >= stepData.stepTime) {
          stepData.totalTime += stepData.stepTime;
          f(stepData.totalTime, stepData.stepTime);
          _results.push(stepData.accumulator -= stepData.stepTime);
        }
        return _results;
      }
    };
  });

  module("Images", [], function(m) {
    var module;
    return module = {
      loadImages: function(imagePaths, onLoad) {
        var image, imagePath, images, numberOfImagesToLoad, _i, _len, _results;
        images = {};
        numberOfImagesToLoad = imagePaths.length;
        _results = [];
        for (_i = 0, _len = imagePaths.length; _i < _len; _i++) {
          imagePath = imagePaths[_i];
          image = new Image;
          images[imagePath] = image;
          image.onload = function() {
            numberOfImagesToLoad -= 1;
            if (numberOfImagesToLoad === 0) {
              return onLoad(images);
            }
          };
          _results.push(image.src = imagePath);
        }
        return _results;
      },
      process: function(rawImages) {
        var imageId, imagePath, images, rawImage;
        images = {};
        for (imagePath in rawImages) {
          rawImage = rawImages[imagePath];
          imageId = imagePath.substring(imagePath.indexOf("/") + 1);
          images[imageId] = {
            rawImage: rawImage,
            positionOffset: [-rawImage.width / 2, -rawImage.height / 2],
            orientationOffset: 0
          };
        }
        return images;
      }
    };
  });

  module("Events", [], function(m) {
    var module, publishToSubscribersOfEvent, publishToSubscribersOfTopic;
    module = {
      anyEvent: "any event",
      anyTopic: "any topic",
      createEvents: function() {
        return {
          subscribers: {},
          queue: []
        };
      },
      subscribe: function(events, eventType, topics, subscriber) {
        var subscribersOfEventByTopic, subscribersOfTopic, topic, _i, _len;
        if (!(topics instanceof Array)) {
          throw "You must specify an array of topics.";
        }
        subscribersOfEventByTopic = events.subscribers[eventType];
        if (subscribersOfEventByTopic == null) {
          subscribersOfEventByTopic = {};
        }
        for (_i = 0, _len = topics.length; _i < _len; _i++) {
          topic = topics[_i];
          subscribersOfTopic = subscribersOfEventByTopic[topic];
          if (subscribersOfTopic == null) {
            subscribersOfTopic = [];
          }
          subscribersOfTopic.push(subscriber);
          subscribersOfEventByTopic[topic] = subscribersOfTopic;
        }
        return events.subscribers[eventType] = subscribersOfEventByTopic;
      },
      publish: function(events, eventType, topic, args) {
        return events.queue.push({
          type: eventType,
          topic: topic,
          args: args
        });
      },
      execute: function(events) {
        var i, queuedEvent;
        i = 0;
        while (i < events.queue.length) {
          queuedEvent = events.queue[i];
          i += 1;
          publishToSubscribersOfEvent(events.subscribers[queuedEvent.type], queuedEvent.topic, queuedEvent.args);
          publishToSubscribersOfEvent(events.subscribers[module.anyEvent], queuedEvent.topic, queuedEvent.args);
        }
        return events.queue.length = 0;
      },
      publishAndExecute: function(events, eventType, topic, args) {
        module.publish(events, eventType, topic, args);
        return module.execute(events);
      }
    };
    publishToSubscribersOfEvent = function(subscribersOfEventByTopic, topic, args) {
      if (subscribersOfEventByTopic != null) {
        publishToSubscribersOfTopic(subscribersOfEventByTopic[topic], args);
        return publishToSubscribersOfTopic(subscribersOfEventByTopic[module.anyTopic], args);
      }
    };
    publishToSubscribersOfTopic = function(subscribersOfTopic, args) {
      var subscriber, _i, _len, _results;
      if (subscribersOfTopic != null) {
        _results = [];
        for (_i = 0, _len = subscribersOfTopic.length; _i < _len; _i++) {
          subscriber = subscribersOfTopic[_i];
          _results.push(subscriber.apply(void 0, args));
        }
        return _results;
      }
    };
    return module;
  });

  module("MainLoop", [], function(m) {
    var defaultCallNextFrame, maxFrameTimeInMs, module;
    maxFrameTimeInMs = 1000 / 30;
    defaultCallNextFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
      return window.setTimeout(function() {
        return f(Date.now());
      }, 1000 / 60);
    };
    return module = {
      execute: function(f, callNextFrame) {
        var gameTimeInS, mainLoop, previousTimeInMs;
        callNextFrame = callNextFrame || defaultCallNextFrame;
        previousTimeInMs = null;
        gameTimeInS = 0;
        mainLoop = function(currentTimeInMs) {
          var frameTimeInMs, frameTimeInS;
          frameTimeInMs = currentTimeInMs - previousTimeInMs;
          previousTimeInMs = currentTimeInMs;
          frameTimeInMs = Math.min(frameTimeInMs, maxFrameTimeInMs);
          frameTimeInS = frameTimeInMs / 1000;
          gameTimeInS += frameTimeInS;
          f(gameTimeInS, frameTimeInS);
          return callNextFrame(mainLoop);
        };
        return callNextFrame(mainLoop);
      }
    };
  });

  module("Entities", [], function(m) {
    var module;
    return module = {
      createEntity: function(factories, components, type, args) {
        var component, componentName, entity, factory, _ref;
        factory = factories[type];
        if (factory == null) {
          throw "Entity type \"" + type + "\" is not known.";
        }
        entity = factory(args);
        _ref = entity.components;
        for (componentName in _ref) {
          component = _ref[componentName];
          if (components[componentName] == null) {
            components[componentName] = {};
          }
          components[componentName][entity.id] = component;
        }
        return entity.id;
      },
      destroyEntity: function(components, entityId) {
        var componentMap, componentType, _results;
        _results = [];
        for (componentType in components) {
          componentMap = components[componentType];
          _results.push(delete componentMap[entityId]);
        }
        return _results;
      }
    };
  });

  module("Input", ["Events"], function(m) {
    var ensureKeyNameIsValid, keyCode, keyCodesByName, keyName, keyNameArrayToKeyCodeSet, keyNamesByCode, module, mouseKeyCodesByName, mouseKeyNamesByCode, updatePointerPosition;
    keyNamesByCode = {
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      19: "pause",
      20: "caps lock",
      27: "escape",
      32: "space",
      33: "page up",
      34: "page down",
      35: "end",
      36: "home",
      37: "left arrow",
      38: "up arrow",
      39: "right arrow",
      40: "down arrow",
      45: "insert",
      46: "delete",
      48: "0",
      49: "1",
      50: "2",
      51: "3",
      52: "4",
      53: "5",
      54: "6",
      55: "7",
      56: "8",
      57: "9",
      65: "a",
      66: "b",
      67: "c",
      68: "d",
      69: "e",
      70: "f",
      71: "g",
      72: "h",
      73: "i",
      74: "j",
      75: "k",
      76: "l",
      77: "m",
      78: "n",
      79: "o",
      80: "p",
      81: "q",
      82: "r",
      83: "s",
      84: "t",
      85: "u",
      86: "v",
      87: "w",
      88: "x",
      89: "y",
      90: "z",
      91: "left window key",
      92: "right window key",
      93: "select key",
      96: "numpad 0",
      97: "numpad 1",
      98: "numpad 2",
      99: "numpad 3",
      100: "numpad 4",
      101: "numpad 5",
      102: "numpad 6",
      103: "numpad 7",
      104: "numpad 8",
      105: "numpad 9",
      106: "multiply",
      107: "add",
      109: "subtract",
      110: "decimal point",
      111: "divide",
      112: "f1",
      113: "f2",
      114: "f3",
      115: "f4",
      116: "f5",
      117: "f6",
      118: "f7",
      119: "f8",
      120: "f9",
      121: "f10",
      122: "f11",
      123: "f12",
      144: "num lock",
      145: "scroll lock",
      186: "semi-colon",
      187: "equal sign",
      188: "comma",
      189: "dash",
      190: "period",
      191: "forward slash",
      192: "grave accent",
      219: "open bracket",
      220: "back slash",
      221: "close braket",
      222: "single quote"
    };
    mouseKeyNamesByCode = {
      0: "left mouse button",
      1: "middle mouse button",
      2: "right mouse button"
    };
    keyCodesByName = {};
    for (keyCode in keyNamesByCode) {
      keyName = keyNamesByCode[keyCode];
      keyCodesByName[keyName] = parseInt(keyCode);
    }
    mouseKeyCodesByName = {};
    for (keyCode in mouseKeyNamesByCode) {
      keyName = mouseKeyNamesByCode[keyCode];
      mouseKeyCodesByName[keyName] = parseInt(keyCode);
    }
    ensureKeyNameIsValid = function(keyName) {
      if (!((keyCodesByName[keyName] != null) || (mouseKeyCodesByName[keyName] != null))) {
        throw "\"" + keyName + "\" is not a valid key name.";
      }
    };
    keyNameArrayToKeyCodeSet = function(keyNameArray) {
      var keyCodeSet, _i, _len;
      keyCodeSet = {};
      for (_i = 0, _len = keyNameArray.length; _i < _len; _i++) {
        keyName = keyNameArray[_i];
        keyCode = keyCodesByName[keyName];
        keyCodeSet[keyCode] = true;
      }
      return keyCodeSet;
    };
    updatePointerPosition = function(pointerPosition, display, event) {
      var element, left, top;
      element = display.canvas;
      left = 0;
      top = 0;
      while (element != null) {
        left += element.offsetLeft;
        top += element.offsetTop;
        element = element.offsetParent;
      }
      pointerPosition[0] = event.clientX - left + window.pageXOffset;
      pointerPosition[1] = event.clientY - top + window.pageYOffset;
      pointerPosition[0] -= display.size[0] / 2;
      return pointerPosition[1] -= display.size[1] / 2;
    };
    return module = {
      keyNamesByCode: keyNamesByCode,
      mouseKeyNamesByCode: mouseKeyNamesByCode,
      keyCodesByName: keyCodesByName,
      mouseKeyCodesByName: mouseKeyCodesByName,
      preventDefaultFor: function(keyNames) {
        var keyCodeSet;
        keyCodeSet = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keyCodeSet[keyDownEvent.keyCode]) {
            return keyDownEvent.preventDefault();
          }
        });
      },
      createCurrentInput: function(display) {
        var currentInput;
        currentInput = {
          pressedKeys: {},
          pointerPosition: [0, 0]
        };
        window.addEventListener("keydown", function(keyDownEvent) {
          keyName = keyNamesByCode[keyDownEvent.keyCode];
          return currentInput.pressedKeys[keyName] = true;
        });
        window.addEventListener("keyup", function(keyUpEvent) {
          keyName = keyNamesByCode[keyUpEvent.keyCode];
          return currentInput.pressedKeys[keyName] = false;
        });
        window.addEventListener("mousedown", function(event) {
          keyName = mouseKeyNamesByCode[event.button];
          return currentInput.pressedKeys[keyName] = true;
        });
        window.addEventListener("mouseup", function(event) {
          keyName = mouseKeyNamesByCode[event.button];
          return currentInput.pressedKeys[keyName] = false;
        });
        display.canvas.addEventListener("mousemove", function(mouseMoveEvent) {
          return updatePointerPosition(currentInput.pointerPosition, display, mouseMoveEvent);
        });
        return currentInput;
      },
      createInputEvents: function(display) {
        var inputEvents;
        inputEvents = m.Events.createEvents();
        display.canvas.addEventListener("mousemove", function(mouseMoveEvent) {
          var pointerPosition;
          pointerPosition = [0, 0];
          updatePointerPosition(pointerPosition, display, mouseMoveEvent);
          return m.Events.publishAndExecute(inputEvents, "mousemove", [], [pointerPosition, mouseMoveEvent]);
        });
        window.addEventListener("click", function(clickEvent) {
          var pointerPosition;
          pointerPosition = [0, 0];
          updatePointerPosition(pointerPosition, display, clickEvent);
          return m.Events.publishAndExecute(inputEvents, "click", [], [pointerPosition, clickEvent]);
        });
        return inputEvents;
      },
      isKeyDown: function(currentInput, keyName) {
        ensureKeyNameIsValid(keyName);
        return currentInput.pressedKeys[keyName] === true;
      }
    };
  });

  module("Rendering", [], function(m) {
    var module;
    return module = {
      drawFunctions: {
        "image": function(context, properties, image, imageId) {
          var alpha, orientation, position, scale;
          if (image == null) {
            throw "Image \"" + imageId + "\" can not be found.";
          }
          position = properties.position || [0, 0];
          orientation = properties.orientation || 0;
          scale = properties.scale || [1, 1];
          alpha = properties.alpha || 1;
          context.globalAlpha = alpha;
          context.translate(position[0], position[1]);
          context.rotate(orientation + image.orientationOffset);
          context.scale(scale[0], scale[1]);
          context.translate(image.positionOffset[0], image.positionOffset[1]);
          return context.drawImage(image.rawImage, 0, 0);
        },
        "text": function(context, properties) {
          var alpha, color, fill, font, orientation, position, text, textAlign, textBaseline;
          text = properties.text;
          position = properties.position || [0, 0];
          orientation = properties.orientation || 0;
          color = properties.color || "rgb(255,105,180)";
          font = properties.font || "10pt Arial";
          alpha = properties.alpha || 1;
          textAlign = properties.align || "center";
          textBaseline = properties.baseline || "alphabetic";
          fill = properties.fill || true;
          context.font = font;
          context.globalAlpha = alpha;
          context.textAlign = textAlign;
          context.textBaseline = textBaseline;
          context.translate(position[0], position[1]);
          context.rotate(orientation);
          if (fill) {
            context.fillStyle = color;
            return context.fillText(text, 0, 0);
          } else {
            context.strokeStyle = color;
            return context.strokeText(text, 0, 0);
          }
        },
        "line": function(context, properties) {
          var alpha, cap, color, end, start, width;
          start = properties.start;
          end = properties.end;
          alpha = properties.alpha || 1;
          color = properties.color || "rgb(0,0,0)";
          width = properties.width || 1;
          cap = properties.cap || "butt";
          context.globalAlpha = alpha;
          context.strokeStyle = color;
          context.lineWidth = width;
          context.lineCap = cap;
          context.beginPath();
          context.moveTo(start[0], start[1]);
          context.lineTo(end[0], end[1]);
          return context.stroke();
        },
        "rectangle": function(context, properties) {
          var color, fill, position, size;
          position = properties.position;
          size = properties.size;
          color = properties.color || "rgb(255,255,255)";
          fill = properties.fill || true;
          if (fill) {
            context.fillStyle = color;
            return context.fillRect(position[0], position[1], size[0], size[1]);
          } else {
            context.strokeStyle = color;
            return context.strokeRect(position[0], position[1], size[0], size[1]);
          }
        }
      },
      createRenderData: function(drawFunctions, data) {
        var drawFunction, renderData, renderableType;
        renderData = {};
        for (renderableType in drawFunctions) {
          drawFunction = drawFunctions[renderableType];
          renderData[renderableType] = data[renderableType] || {};
        }
        return renderData;
      },
      createDisplay: function() {
        var canvas, context, display;
        canvas = document.getElementById("canvas");
        context = canvas.getContext("2d");
        context.translate(canvas.width / 2, canvas.height / 2);
        return display = {
          canvas: canvas,
          context: context,
          size: [canvas.width, canvas.height]
        };
      },
      createRenderable: function(type, properties, reference) {
        var renderable;
        return renderable = {
          type: type,
          properties: properties,
          reference: reference
        };
      },
      render: function(drawFunctions, display, renderData, renderables) {
        var context, drawFunction, height, renderable, resources, width, _i, _len, _results;
        context = display.context;
        width = display.size[0];
        height = display.size[1];
        context.clearRect(-width / 2, -height / 2, width, height);
        _results = [];
        for (_i = 0, _len = renderables.length; _i < _len; _i++) {
          renderable = renderables[_i];
          context.save();
          resources = renderData[renderable.type];
          drawFunction = drawFunctions[renderable.type];
          if (drawFunction == null) {
            throw "There is no draw function for renderable type \"" + renderable.type + "\".";
          }
          drawFunction(context, renderable.properties, resources[renderable.reference], renderable.reference);
          _results.push(context.restore());
        }
        return _results;
      }
    };
  });

  module("Vec2", [], function(m) {
    var module;
    return module = {
      copy: function(v) {
        return [v[0], v[1]];
      },
      overwrite: function(v1, v2) {
        v1[0] = v2[0];
        return v1[1] = v2[1];
      },
      equals: function(v1, v2) {
        return v1[0] === v2[0] && v1[1] === v2[1];
      },
      scale: function(v, s) {
        v[0] *= s;
        return v[1] *= s;
      },
      add: function(v1, v2) {
        v1[0] += v2[0];
        return v1[1] += v2[1];
      },
      subtract: function(v1, v2) {
        v1[0] -= v2[0];
        return v1[1] -= v2[1];
      },
      dot: function(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
      },
      perpDot: function(v1, v2) {
        return -v1[1] * v2[0] + v1[0] * v2[1];
      },
      length: function(v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
      },
      squaredLength: function(v) {
        return v[0] * v[0] + v[1] * v[1];
      },
      normalize: function(v) {
        var length;
        length = module.length(v);
        v[0] /= length;
        return v[1] /= length;
      },
      perp: function(v) {
        var x, y;
        x = v[0];
        y = v[1];
        v[0] = -y;
        return v[1] = x;
      },
      applyTransform: function(v, t) {
        var x, y;
        x = v[0], y = v[1];
        v[0] = x * t[0][0] + y * t[0][1] + 1 * t[0][2];
        return v[1] = x * t[1][0] + y * t[1][1] + 1 * t[1][2];
      }
    };
  });

  module("Transform2d", [], function(m) {
    var module;
    return module = {
      identityMatrix: function() {
        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      },
      translationMatrix: function(v) {
        return [[1, 0, v[0]], [0, 1, v[1]], [0, 0, 1]];
      },
      rotationMatrix: function(angle) {
        return [[Math.cos(angle), -Math.sin(angle), 0], [Math.sin(angle), Math.cos(angle), 0], [0, 0, 1]];
      },
      scalingMatrix: function(factor) {
        return [[factor, 0, 0], [0, factor, 0], [0, 0, 1]];
      }
    };
  });

  module("Mat3x3", [], function(m) {
    var module;
    return module = {
      multiply: function(m1, m2) {
        var m00, m01, m02, m10, m11, m12, m20, m21, m22;
        m00 = m1[0][0];
        m01 = m1[0][1];
        m02 = m1[0][2];
        m10 = m1[1][0];
        m11 = m1[1][1];
        m12 = m1[1][2];
        m20 = m1[2][0];
        m21 = m1[2][1];
        m22 = m1[2][2];
        m1[0][0] = m00 * m2[0][0] + m01 * m2[1][0] + m02 * m2[2][0];
        m1[0][1] = m00 * m2[0][1] + m01 * m2[1][1] + m02 * m2[2][1];
        m1[0][2] = m00 * m2[0][2] + m01 * m2[1][2] + m02 * m2[2][2];
        m1[1][0] = m10 * m2[0][0] + m11 * m2[1][0] + m12 * m2[2][0];
        m1[1][1] = m10 * m2[0][1] + m11 * m2[1][1] + m12 * m2[2][1];
        m1[1][2] = m10 * m2[0][2] + m11 * m2[1][2] + m12 * m2[2][2];
        m1[2][0] = m20 * m2[0][0] + m21 * m2[1][0] + m22 * m2[2][0];
        m1[2][1] = m20 * m2[0][1] + m21 * m2[1][1] + m22 * m2[2][1];
        return m1[2][2] = m20 * m2[0][2] + m21 * m2[1][2] + m22 * m2[2][2];
      }
    };
  });

  module("ControlMissiles", ["Vec2", "Transform2d"], function(m) {
    return function(frameTimeInS, missileControls, bodies, destroyEntity) {
      var angle, missileBody, missileControl, missileId, missileSpeed, missileToTarget, perpDotProduct, rotationDirection, rotationPerS, t, targetBody, _results;
      _results = [];
      for (missileId in missileControls) {
        missileControl = missileControls[missileId];
        missileBody = bodies[missileId];
        targetBody = bodies[missileControl.targetId];
        if (targetBody != null) {
          missileToTarget = m.Vec2.copy(targetBody.position);
          m.Vec2.subtract(missileToTarget, missileBody.position);
          if (missileControl.targetAcquired) {
            angle = m.Vec2.dot(missileToTarget, missileBody.velocity);
            angle /= m.Vec2.length(missileToTarget) * m.Vec2.length(missileBody.velocity);
            angle = Math.acos(angle);
            perpDotProduct = m.Vec2.perpDot(missileBody.velocity, missileToTarget);
            rotationDirection = perpDotProduct === 0 ? m.Vec2.dot(missileBody.velocity, missileToTarget) > 0 ? 0 : -1 : perpDotProduct < 0 ? -1 : 1;
            rotationPerS = 1.2;
            angle = rotationDirection * rotationPerS * frameTimeInS;
            t = m.Transform2d.rotationMatrix(angle);
            m.Vec2.applyTransform(missileBody.velocity, t);
            _results.push(missileBody.orientation = Math.atan2(missileBody.velocity[1], missileBody.velocity[0]));
          } else {
            missileSpeed = 70;
            m.Vec2.normalize(missileToTarget);
            m.Vec2.scale(missileToTarget, missileSpeed);
            missileBody.velocity = missileToTarget;
            _results.push(missileControl.targetAcquired = true);
          }
        } else {
          _results.push(destroyEntity(missileId));
        }
      }
      return _results;
    };
  });

}).call(this);
